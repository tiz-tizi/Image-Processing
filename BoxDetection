import numpy as np
import scipy.io as sio
import matplotlib.pyplot as plt
import cv2

def estimate_plane(points):
    """
    Estimate a plane from a set of 3D points using Singular Value Decomposition (SVD).
    """
    # Compute the centroid of the points
    centroid = np.mean(points, axis=0)

    # Compute the covariance matrix of the points
    cov = np.cov(points.T)

    # Perform SVD on the covariance matrix
    U, S, V = np.linalg.svd(cov)

    # The normal vector of the plane is the last column of the V matrix
    normal = V[-1]

    # Flip the normal vector if it points away from the centroid
    if np.dot(normal, centroid) > 0:
        normal = -normal

    # Return the plane parameters as a numpy array [a, b, c, d] such that ax + by + cz + d = 0
    return np.concatenate([normal, [-np.dot(normal, centroid)]])

def ransac_plane(points, n_iterations=100, threshold=0.1):
    """
    Estimate a plane from a set of 3D points using RANSAC (Random Sample Consensus).
    """
    best_plane = None
    best_error = float('inf')
    inliers_mask = np.zeros(points.shape[0], dtype=bool)
    for i in range(n_iterations):
        # Choose three points at random
        samples = points[np.random.choice(points.shape[0], 3, replace=False)]

        # Estimate a plane using these points
        plane = estimate_plane(samples)

        # Compute the distance between the plane and all points
        errors = np.abs(np.dot(points, plane[:-1]) + plane[-1])

        # Count the number of inliers (points within the threshold distance of the plane)
        inliers = errors < threshold

        # Update the best plane if this one is better
        if np.sum(inliers) > np.sum(inliers_mask) and np.sum(inliers) > 0 and np.sum(errors) < best_error:
            best_plane = plane
            best_error = np.sum(errors)
            inliers_mask = inliers

    # Return the best plane and the inliers mask
    return best_plane, inliers_mask

# Load .mat file
data = sio.loadmat('example2kinect.mat')

# Access amplitude image
amplitude_image = data['amplitudes2']

# Access distance image
distance_image = data['distances2']

# Access point cloud
point_cloud = data['cloud2']

# Convert point cloud to 3D numpy array
point_cloud_3d = np.reshape(point_cloud, (424*512, 3))

# Filter out points with z-component equal to 0 (invalid measurements)
valid_points = point_cloud_3d[point_cloud_3d[:, 2] != 0]

# Run RANSAC to estimate a plane from the valid point cloud and obtain the inliers mask
plane1, inliers_mask = ransac_plane(valid_points)

# Create binary mask image for inliers
mask_image = np.zeros((424, 512), dtype=int)
valid_indices = np.nonzero(point_cloud[:, :, 2].flatten())  # Get valid indices where z-component is not 0
mask_image[np.unravel_index(valid_indices, (424, 512))] = inliers_mask.astype(int).flatten()

